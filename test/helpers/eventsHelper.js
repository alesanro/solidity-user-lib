const abiDecoder = require('abi-decoder')

function EventsHelper() {
	var allEventsWatcher = undefined

	const self = this

	var waitReceipt = function(transactionHash, address) {
		//console.log(transactionHash.transactionHash);
		return new Promise(function(resolve) {
			var transactionCheck = function() {
				//web3.eth.getTransactionReceipt(transactionHash.transactionHash, function(err, transaction) {
				//  console.info(transaction);
				var receipt = transactionHash.receipt
				// console.log(receipt);
				if (receipt) {
					var count = 0
					if (address) {
						receipt.logs.forEach(function(log) {
							count += log.address === address ? 1 : 0
						})
					}
					else {
						count = receipt.logs.length
					}
					return resolve(count)
				}
				//else {
				//          setTimeout(transactionCheck, 100);
				//        }
				//  });
			}
			transactionCheck()
		})
	}

	var waitEvents = function(watcher, count) {
		return new Promise(function(resolve, reject) {
			var transactionCheck = function() {
				watcher.get(function(err, events) {
					if (err) {
						console.log(err)
						return reject(err)
					}
					if (events) {
						if (events.length === count) {
							return resolve(events)
						}
						if (events.length > count) {
							console.log(events)
							return reject("Filter produced " + events.length + " events, while receipt produced only " + count + " logs.")
						}
					}
					setTimeout(transactionCheck, 100)
				})
			}
			transactionCheck()
		})
	}

	this.getEvents = function(transactionHash, watcher) {
		if (allEventsWatcher === undefined) {
			throw "Call setupEvents before target transaction send."
		}
		return new Promise(function(resolve, reject) {
			waitReceipt(transactionHash, watcher.options.address).then(function(logsCount) {
				return waitEvents(allEventsWatcher, logsCount)
			}).then(function() {
				watcher.get(function(err, events) {
					if (err) {
						console.log(err)
						return reject(err)
					}
					return resolve(events)
				})
			})
		})
	}

	this.setupEvents = function(contract) {
		allEventsWatcher = contract.allEvents()
		//console.log("all events for contract:" + JSON.stringify(allEventsWatcher, null, 5));
	}

	this.extractEvents = function(txHash, eventName) {
		if (txHash.logs.length === 0) {
			return []
		}

		const logs = txHash.logs
		var filteredLogs = []
		for (var logEntry of logs) {
			if (logEntry.event.toLowerCase() === eventName.toLowerCase()) {
				filteredLogs.push(logEntry)
			}
		}
		return filteredLogs
	}

	this.extractReceiptLogs = (tx, eventWatcher) => {
		return new Promise(resolve => {
			const receipt = tx.receipt
			if (receipt.logs.length === 0) {
				resolve([])
				return
			}

			var logs = []
			for (var logEntry of receipt.logs) {
				if (logEntry.topics[0].toLowerCase() === eventWatcher.options.topics[0].toLowerCase()) {

					logs.push(logEntry)
				}
			}

			resolve(logs)
		})
	}


	// Decode and find events from receipt generated by `contracts`
	this.findEvent = async (contracts, tx, eventName) => {
		return await self.findEvents(contracts, tx, e => e.name === eventName)
	}

	// Decode and find events from receipt generated by `contracts`
	this.findEvents = async (contracts, tx, comparator) => {
		contracts.forEach(c => abiDecoder.addABI(c.abi))

		const logs = abiDecoder.decodeLogs(tx.receipt.logs)
		const events = logs
			.filter(l => l !== undefined)
			.filter(l => l !== null)
			.filter(l => comparator(l))
			.map(l => _updateWithArgs(l))

		contracts.forEach(c => abiDecoder.removeABI(c.abi))

		return await Promise.resolve(events)
	}

	function _updateWithArgs(event) {
		var args = {}
		for (var arg of event.events) {
			args[arg.name] = arg.value
		}

		event["args"] = args

		return event
	}

}

module.exports = new EventsHelper()
